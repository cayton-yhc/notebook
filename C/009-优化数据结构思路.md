# 从“反转+补0”到“双指针+缺位当0”的优化

## 题面直觉做法（你最初的思路）
- 按题意把两数 **反转**。
- **补零**：把短的那串在高位（反转后尾部）补 0，使长度一致。
- 逐位相加并维护 `carry`。
- 问题：需要两次数据搬运（反转与补零），分支多、边界细节繁琐。

## 关键洞见
- **补零是“为了对齐”**，但对齐不一定要修改数据结构。
- 只要在读取时把 **越界位视为 0（缺位当 0）**，就等价于“补零”，且无需真的补。

## 优化后的统一写法（你的目标思路）
- **双指针从右到左**（最低位→最高位），每轮：
  1. 读 `da = (i>=0 ? A[i]-'0' : 0)`  
     `db = (j>=0 ? B[j]-'0' : 0)`
  2. `s = da + db + carry`，根据 `s>=10` 更新 `carry/统计`。
  3. `--i; --j;`
- **无需反转、无需补零、无需按长度分支**。

## 伪代码（可直接套用）
```c
int i = lenA - 1, j = lenB - 1, carry = 0, cnt = 0;
while (i >= 0 || j >= 0) {
    int da = (i >= 0 ? A[i] - '0' : 0);
    int db = (j >= 0 ? B[j] - '0' : 0);
    int s  = da + db + carry;
    if (s >= 10) { ++cnt; carry = 1; }
    else carry = 0;
    --i; --j;
}
```
