# dfs函数实现思路总结

## 返回值
大部分dfs是不需要返回值的，它们往往直接使用和修改全局变量

## 题型分类

 组合
 排列
 图搜索
 子集

## 参数
1. 至少需要一个index去触探边界值————防止越界
2. 遇到选与不选时——
    1. 若明确选择个数，则本质为组合数C(n,k)，增加一个count
    2. 若不明确，则本质为排列数C(n,1)→C(n,k)→C(n,n)，不需要count
3. 遇到排列生成时只需要index or depth————但需要内置for循环确定每个数出现
4. 遇到图搜索时需要坐标x，y以及标记数组————防止走回头路
5. 遇到子集问题，同上不明确时的选择

## 题目案例

### 组合枚举
既要确保不越界，又要保证找到k个数
```c
void dfs(int idx, int cnt) {
    if (cnt == K) {
        // 输出或统计组合
        return;
    }
    if (idx == N) return;

    // 选当前数
    dfs(idx+1, cnt+1);
    // 不选当前数
    dfs(idx+1, cnt);
}
```

### 排列生成
内置for循环，保证每位都在遍历
```c
void dfs(int depth) {
    if (depth == N) {
        // 输出排列
        return;
    }
    for (int i=1; i<=N; i++) {
        if (!vis[i]) {
            vis[i] = 1;
            path[depth] = i;
            dfs(depth+1);
            vis[i] = 0; // 回溯
        }
    }
}
```

### 图搜索

```c
void dfs(int x, int y) {
    if (到达终点) { 标记成功; return; }
    vis[x][y] = 1;
    for (四个方向) {
        if (合法 && !vis[nx][ny]) {
            dfs(nx, ny);
        }
    }
}
```

### 子集

```c
void dfs(int idx, int cnt) {
   void dfs(int idx) {
    if (idx == N) {
        // 输出当前子集
        return;
    }
    // 不选当前元素
    dfs(idx+1);
    // 选当前元素
    choose.push_back(A[idx]);
    dfs(idx+1);
    choose.pop_back();
}

}
```

## 基本形式
前面放条件，后面放回溯与递推