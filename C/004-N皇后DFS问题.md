# N 皇后问题总结

## 📌 问题简介
- 在 `n × n` 棋盘上放置 `n` 个皇后，使它们互不攻击：  
  - 不在同一行  
  - 不在同一列  
  - 不在同一条对角线  
- 目标：输出所有合法摆放方案。

---

## 🔍 问题分析
- **递归深度**：一行一行放皇后，`dfs(row)` 表示在第 `row` 行放一个皇后。  
- **搜索空间**：每行有 `n` 种列选择，总共约 `n^n` 种可能，通过剪枝大幅减少。  
- **关键剪枝**：放皇后前检查列、主对角、副对角是否已被占用。

---

## ⚠️ 常见错误与改正
1. **棋盘表示混乱**  
   - ❌ 用二维数组打印时下标出错  
   - ✅ 用一维数组 `pos[row] = col` 表示第 `row` 行的皇后位置  

2. **递归参数设计不合理**  
   - ❌ 使用 `(x, y, num)` 混合递归，逻辑复杂  
   - ✅ 只用 `row`，因为每行必须放一个皇后  

3. **对角线判断错误**  
   - ❌ 错误表达式 `(x-j)%n`  
   - ✅ 正确方法：  
     - 主对角线 ↘：`row - col` 固定  
     - 副对角线 ↙：`row + col` 固定  

4. **回溯不完整**  
   - ❌ 忘记撤销标记，导致状态污染  
   - ✅ 放皇后 → 标记 → 递归 → 回溯取消标记  

---

## ✨ 新收获
- **用一维数组表示二维棋盘**  
  - `pos[row] = col`  
  - 打印时，根据 `pos` 来决定在哪一列输出 `Q`  

- **斜对角表示方法**  
  - 主对角线：`row - col` 相同  
  - 副对角线：`row + col` 相同  
  - 使用两个数组 `diag1[]`、`diag2[]` 记录占用情况  

- **存在占位的判断**  
  - `col[c]` → 判断列是否被占用  
  - `diag1[row-col+n]` → 判断主对角是否被占用  
  - `diag2[row+col]` → 判断副对角是否被占用  

---

## ✅ 小结
- N 皇后问题本质是 **DFS 回溯**：在一棵 `n` 叉树上搜索，每层代表一行，每个分支代表可能的列位置。  
- 解法关键：  
  1. 用一维数组简化棋盘表示  
  2. 用对角线标记实现冲突检测  
  3. 保证递归和回溯完整  
